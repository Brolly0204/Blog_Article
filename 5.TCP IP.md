# 理解TCP/IP协议

## 一、协议

在计算机网络与信息通讯领域里，人们经常提及 “协议” 一词。互联网中常用的协议有HTTP、TCP、IP等。

## 协议的必要性

简单来说，协议就是计算机与计算机之间通过网络通信时，事先达成的一种 “约定”。这种“约定”使不同厂商的设备、不同的CPU以及不同操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。这就好比一个中国人说汉语一个外国人说英语使用不同的国家语言进行沟通，怎么也无法理解。如果两个人约定好 都说中文或英文，就可以互相沟通通信。协议分为很多种，每一种协议都明确界定了它的行为规范。两台计算机必须能够支持相同的协议，并遵循相同协议进行处理，这样才能实现相互通信。

## 二、协议分层

## TCP/IP协议

TCP/IP 是用于因特网 (Internet) 的通信协议。 TCP/IP 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。

> TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复 用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、 流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。 TCP支持的应用协议主要有：Telnet、FTP、SMTP等； UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。 TCP/IP协议与低层的数据链路层和物理层无关，这也是TCP/IP的重要特点

* TCP(Transimision Control Protocal)
* 传输控制协议
* 可靠的、面向连接的协议
* 传输效率低
* UDP(User Datagram Protocal)
* 用户数据报协议
* 不可靠的、无连接的服务
* 传输效率高

## TCP/IP协议族

TCP/IP是基于TCP和IP这两个最初的协议之上的不同的通信协议的大集合

![](https://pic3.zhimg.com/v2-3e1ff699008afcd62da9e3341c4c9fbe_b.jpg)

## 协议的分层

网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。 传统上来说 TCP/IP 被认为是一个四层协议, 而ISO（国际标准化组织），制定了一个国际标准OSI七层协议模型，OSI协议以OSI参考模型为基础界定了每个阶层的协议和每个阶层之间接口相关的标准。

![](https://pic2.zhimg.com/v2-4fe0b5f06fc89af2f98ebd2690bc87ea_b.jpg)

## 分层的作用

![](https://pic3.zhimg.com/v2-4f0d5f94dbc6103b807da5dc1bb23478_b.jpg)

## 应用层

应用层为操作系统或网络应用程序提供访问网络服务的接口。应用层协议的代表包括：Telnet、FTP、HTTP、SNMP等。

## 表示层

将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。数据的表示、安全、压缩。

## 会话层

负责建立和断开通信连接（数据流动的逻辑通路），以及数据的分割等数据传输相关的管理。

## 传输层

管理两个节点之间的数据传输。负责可靠传输（确保数据被可靠地传送到目标地址）。

## 网络层

地址管理与路由选择, 在这一层，数据的单位称为数据包（packet）（路由器）。

## 数据链路层

互连设备之间传送和识别数据帧（交换机）。

## 物理层

以"0"、 "1"代表电压的高低，灯光的闪灭，在这一层，数据的单位称为比特（bit）,（中继器、集线器、还有我们通常说的双绞线也工作在物理层）。

## 七层通信

![](https://pic1.zhimg.com/v2-68c6c874e5e2547bbb0bc23fe572c7a6_b.jpg)

发送方由第七层到第一层 由上到下按照顺序传送数据，每个分层在处理上层传递的数据时，附上当前层协议所必须的 "首部"信息。接收方由第一层到第七层 由下到上按照顺序传递数据，每个分层对接收到的数据进行 "首部"与"内容"分离，在转发给上一层。最终将发送的数据恢复为原始数据。

## 三、传输方式的分类

网络通信科根据数据发送方法进行多种分类，分类方法很多，下面列举几种常见的：

1. 面向有连接型和面向无连接型 1.1 面向有连接型

![](https://pic2.zhimg.com/v2-379891bd70b881ace40430cd4fef4ce6_b.jpg)

发送数据之前，需要在收发主机之间建立一条通信线路，在通信传输前后，专门进行建立和断开连接的处理，如果与对端之间无法通信，可避免发送无谓的数据

1.2面向无连接型

![](https://pic4.zhimg.com/v2-1537cf5f46541187a14030c8ff0f8a5b_b.jpg)

## 四、报文、帧、数据包等的区别

> 报文（message）是网络中交换与传输的数据单元，也是网络传输的单元。报文包含了将要发送的完整的数据信息，其长短不需一致。报文在传输过程中会不断地封装成分组、包、帧来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。

应用层：报文（message），一般指完整的信息，传输层实现报文交付，位于应用层的信息分组称为报文； 传输层：报文段（segment），组成报文的每个分组； 网络层：分组（packet）是网络传输中的二进制格式单元，数据包（datapacket）是TCP/IP通信协议传输中的数据单位；通过网络传输的数据基本单元，包含一个报头和数据本身，其中报头描述了数据的目的地及其与其他数据之间的关系，可以理解为数据传输的分组，我们将通过网络传输的基本数据单元称为数据报（Datagram）； 链路层：帧（frame），数据链路层的协议数据单元，为了保证数据的可靠传输，把用户数据封装成帧； 物理层：PDU（bit），协议数据单元； 抓包，抓到的是传输层的包，packet/frame/Datagram/segment是存在于同条记录中的，这些是基于所在协议层的不同取了不同的名字。

## 五、TCP报文

## 数据包

![](https://pic4.zhimg.com/v2-63955c8436410907d6fe4697d5bf0b0c_b.jpg)

IP 数据包在以太网数据包的负载里面，TCP数据包在IP数据包的负载里。

![](https://pic1.zhimg.com/v2-9cdd39da512d2a09a20aa77a05c6b0ad_b.jpg)

## TCP 首部各字段的意义和作用

TCP首部最小为20字节，这20字节分为5行，每行4个字节也就是32个位。

## 源端口和目的端口 Port

* 源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。
* 目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。计算机通过端口号识别访问哪个服务,比如http服务或ftp服务，发送方端口号是进行随机端口，目标端口号决定了接收方哪个程序来接收 分别占用16位，也就是端口号最大是2^16，所以端口号的范围是0~65536

端口号的分配：

* 知名端口号一般位于：1 --- 255 之间
* 256 --- 1023的端口号，通常是由Unix系统占用（系统占用）
* 1024 ---5000 是大多数TCP、IP实现的临时分配
* 大于5000的一般是给其他服务预留的（Internet上并不常用的服务）

## 序号 Sequence Number

TCP用序列号对数据包进行标记，以便在到达目的地后重新重装，假设当前的序列号为 s，发送数据长度为 l，则下次发送数据时的序列号为 s + l。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。

## 确认号 Acknowledgemt Number

占 4 个字节，表示期望收到对方下一个报文段的序号值。 TCP 的可靠性，是建立在「每一个数据报文都需要确认收到」的基础之上的。

就是说，通讯的任何一方在收到对方的一个报文之后，都要发送一个相对应的「确认报文」，来表达确认收到。 那么，确认报文，就会包含确认号。 例如，通讯的一方收到了第一个 25kb 的报文，该报文的 序号值=0，那么就需要回复一个确认报文，其中的确认号 = 25600.

## 数据偏移 Offset

占 0.5 个字节 (4 位)。 这个字段实际上是指出了 TCP 报文段的首部长度 ，它指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。（注意 数据起始处 和 报文起始处 的意思）

一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。

## 保留 Reserved

占 0.75 个字节 (6 位)。 保留为今后使用，但目前应置为 0。

## 标志位 TCP Flags

标志位，一共有 6 个，分别占 1 位，共 6 位 。 每一位的值只有 0 和 1，分别表达不同意思。

* ACK：确认序号有效
* RST：重置连接
* SYN：发起了一个新连接
* FIN：释放一个连接

## 确认 ACK (Acknowlegemt)

当 ACK = 1 的时候，确认号（Acknowledgemt Number）有效。 一般称携带 ACK 标志的 TCP 报文段为「确认报文段」。为0表示数据段不包含确认信息，确认号被忽略。

TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 设置为 1。

## 推送 PSH (Push)

当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。

## 复位 RST (Reset)

当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。 一般称携带 RST 标志的 TCP 报文段为「复位报文段」。

## 同步 SYN (SYNchronization)

当 SYN = 1 的时候，表明这是一个请求连接报文段。 一般称携带 SYN 标志的 TCP 报文段为「同步报文段」。 在 TCP 三次握手中的第一个报文就是同步报文段，在连接建立时用来同步序号。

对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。

## 终止 FIN (Finis)

当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。

一般称携带 FIN 的报文段为「结束报文段」。

在 TCP 四次挥手释放连接的时候，就会用到该标志。

## 窗口大小 Window Size

占 2 字节。

该字段明确指出了现在允许对方发送的数据量，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 窗口大小的值是指，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。

例如，假如确认号是 701 ，窗口字段是 1000。这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 （字节序号是 701 ~ 1700） 个字节的数据的接收缓存空间。

## 校验和 TCP Checksum

占 2 个字节。 由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。

检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。

## 紧急指针 Urgent Pointer

占 2 个字节。 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。 当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。

因此，紧急指针指出了紧急数据的末尾在报文段中的位置。

## 六、三次握手，四次挥手

需要了解的信息：

* ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1
* SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
* FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

## 三次握手 建立连接

TCP（Transmission Control Protocol，传输控制协议）是 面向连接的协议，也就是说在收发数据之前，必须先和对方建立连接

一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的 描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同 步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数 据。

![](https://pic3.zhimg.com/v2-1587e91f14923eae0fa7d846cb10df99_b.jpg)

首先由Client发出请求连接即 SYN=1 ACK=0 (请看头字段的介绍), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的32位序号是 seq=x，然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1, 再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.

## 四次挥手 释放连接

![](https://pic1.zhimg.com/v2-6e5f05603526c1d259b300f20b8857a5_b.jpg)

当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1, 服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。 A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

> 关于 TIME_WAIT 过渡到 CLOSED 状态说明： 从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。

## 为什么要等待呢？

为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B会发送探测信息， 以决定是否释放连接

## 为什么连接的时候是三次握手，关闭的时候却是四次握手？

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

## 参考

* [OSI七层与TCP/IP详解](http://blog.csdn.net/cd520yy/article/details/12968923)
* [TCP/IP报文](https://www.jianshu.com/p/ef892323e68f)
* [TCP三次握手四次挥手](http://blog.csdn.net/xulu_258/article/details/51146489)
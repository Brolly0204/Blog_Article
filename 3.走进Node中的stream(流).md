# NodeJs中的stream（流）- 基础篇

## 一、什么是Stream（流）
> 流（stream）在 Node.js 中是处理流数据的抽象接口（abstract interface）。 stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。

流是可读的、可写的，或是可读写的。

## 二、NodeJs中的Stream的几种类型
Node.js 中有四种基本的流类型：
- Readable - 可读的流（fs.createReadStream()）
- Writable - 可写的流（fs.createWriteStream()）
- Duplex - 可读写的流（net.Socket）
- Transform - 在读写过程中可以修改和变换数据的 Duplex 流 (例如 zlib.createDeflate())

NodeJs中关于流的操作被封装到了Stream模块中，这个模块也被多个核心模块所引用。
```
const stream = require('stream');
```

在 NodeJS 中对文件的处理多数使用流来完成

- 普通文件
- 设备文件（stdin、stdout）
- 网络文件（http、net）

注：在NodeJs中所有的Stream(流)都是EventEmitter的实例

Example：

1.将1.txt的文件内容读取为流数据
```
const fs = require('fs');

// 创建一个可读流（生产者）
let rs = fs.createReadStream('./1.txt'); 
```
通过fs模块提供的createReadStream()可以轻松创建一个可读的文件流。但我们并有直接使用Stream模块，因为fs模块内部已经引用了Stream模块并做了封装。所以说 流（stream）在 Node.js 中是处理流数据的抽象接口，提供了基础Api来构建实现流接口的对象。


```
var rs = fs.createReadStream(path,[options]);
```
1.path 读取文件的路径

2.options
  - flags打开文件的操作, 默认为'r'
  - encoding默认为null
  - start开始读取的索引位置
  - end结束读取的索引位置(包括结束位置)
  - highWaterMark读取缓存区默认的大小64kb

Node.js 提供了多种流对象。 例如： 
- HTTP 请求 （request response）
- process.stdout 就都是流的实例。

2.创建可写流（消费者）处理可读流

将1.txt的可读流 写入到2.txt文件中 这时我们需要一个可写流

```
const fs = require('fs');
// 创建一个可写流
let ws = fs.createWriteStream('./2.txt');
// 通过pipe让可读流流入到可写流 写入文件
rs.pipe(ws); 
```

```
var ws = fs.createWriteStream(path,[options]);
```
1.path 读取文件的路径

2.options
  - flags打开文件的操作, 默认为'w'
  - encoding默认为utf8
  - highWaterMark读取缓存区默认的大小16kb
  
  <img src="https://github.com/Lwenli1224/Blog_Article/raw/master/images/stream-1.png" width="65%" style="margin:atuo">
  </div>
  <br/>
  
pipe 相当于一个"管道"，数据从上游 pipe 到下游，也就是从一个 readable 流 pipe 到 writable 流。 后面我们再详细介绍pipe。

## 三、为什么应该使用 Stream
当有用户在线看视频，假定我们通过HTTP请求返回给用户视频内容
```
const http = require('http');
const fs = require('fs');

http.createServer((req, res) => {
    fs.readFile(videoPath, (err, data) => {
        res.end(data);
    });
}).listen(8080);
```
但这样有两个明显的问题

1.视频文件需要全部读取完，才能返回给用户，这样等待时间会很长
2.视频文件一次全放入内存中，内存吃不消

用流可以将视频文件一点一点读到内存中，再一点一点返回给用户，读一部分，写一部分。（利用了 HTTP 协议的 Transfer-Encoding: chunked 分段传输特性），用户体验得到优化，同时对内存的开销明显下降

```
const http = require('http');
const fs = require('fs');

http.createServer((req, res) => {
    fs.createReadStream(videoPath).pipe(res);
}).listen(8080);
```

## 四、可读流（Readable）
> 可读流（Readable streams）是对提供数据的源头（source）的抽象。

例如:
- HTTP responses, on the client
- HTTP requests, on the server
- fs read streams
- TCP sockets
- process.stdin

所有的 Readable 都实现了 stream.Readable 类定义的接口。

### 可读流的两种模式（flowing 和 paused）
1.在 flowing 模式下， 可读流自动从系统底层读取数据，并通过 EventEmitter 接口的事件尽快将数据提供给应用。

2.在 paused 模式下，必须显式调用 stream.read()方法来从流中读取数据片段。

所有初始工作模式为paused的Readable流，可以通过下面三种途径切换为flowing模式：
- 监听'data'事件
- 调用stream.resume()方法
- 调用stream.pipe()方法将数据发送到Writable

#### 监听data事件
流切换到流动模式
```
const rs = fs.createReadStream('./1.txt');
rs.on('data', chunk => {
    console.log(chunk);
});
```
